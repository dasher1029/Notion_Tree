<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Notion Tree - Visualization</title>
  <link rel="stylesheet" href="css/tree.css">
</head>

<body>
  <button class="back-btn" onclick="location.href='/home.html'">â† ë’¤ë¡œê°€ê¸°</button>

  <div class="header">
    <h1>ğŸ“Š Notion íŠ¸ë¦¬ ì‹œê°í™”</h1>
  </div>

  <div class="tree-container">
    <svg id="tree"></svg>

    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoom(0.1)">+</button>
      <button class="zoom-btn" onclick="zoom(-0.1)">-</button>
      <button class="zoom-btn" onclick="resetZoom()" style="font-size: 1rem;">â†º</button>
    </div>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    let currentScale = 1;
    let baseWidth = 0, baseHeight = 0;
    let baseTx = 0, baseTy = 0;
    let svgSelection, gSelection;

    function zoom(delta) {
      const newScale = currentScale + delta;
      if (newScale < 0.1) return; // Prevent too small
      currentScale = newScale;
      updateZoom();
    }

    function resetZoom() {
      currentScale = 1;
      updateZoom();
    }

    function updateZoom() {
      if (svgSelection && gSelection) {
        // 1. Update SVG size to trigger scrollbars
        svgSelection
          .attr("width", baseWidth * currentScale)
          .attr("height", baseHeight * currentScale);

        // 2. Scale the content
        // We use scale(s) translate(tx, ty) which scales the coordinate system first.
        // But wait, if we scale first, the translation units are also scaled.
        // We want the original translation (tx, ty) to be scaled to (tx*s, ty*s).
        // scale(s) translate(tx, ty) -> effective translation is tx*s, ty*s.
        // This is exactly what we want to keep the tree centered/positioned relatively.
        gSelection.attr("transform", `scale(${currentScale}) translate(${baseTx}, ${baseTy})`);
      }
    }

    async function loadTree() {
      try {
        const res = await fetch("/api/tree-data", { credentials: "include" });
        const data = await res.json();

        if (!data || Object.keys(data).length === 0) {
          document.querySelector('.tree-container').innerHTML = '<div style="margin:auto; color:#555;">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
          return;
        }

        const root = d3.hierarchy(data);

        // ğŸŒŸ íŠ¸ë¦¬ ë ˆì´ì•„ì›ƒ ê°„ê²© ì„¤ì •
        const treeLayout = d3.tree()
          .nodeSize([150, 100]); // [ê°€ë¡œ ê°„ê²©, ì„¸ë¡œ ê°„ê²©]

        // ë ˆì´ì•„ì›ƒ ê³„ì‚°
        treeLayout(root);

        // ğŸŒŸ 1. íŠ¸ë¦¬ ë°”ìš´ë”ë¦¬ ê³„ì‚°
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        root.descendants().forEach(d => {
          if (d.x < minX) minX = d.x;
          if (d.x > maxX) maxX = d.x;
          if (d.y < minY) minY = d.y;
          if (d.y > maxY) maxY = d.y;
        });

        // ì—¬ë°± ì„¤ì •
        const padding = { top: 50, right: 150, bottom: 80, left: 150 };

        // ğŸŒŸ 2. ê¸°ë³¸ í¬ê¸° ë° ìœ„ì¹˜ ê³„ì‚°
        baseWidth = (maxX - minX) + padding.left + padding.right;
        baseHeight = (maxY - minY) + padding.top + padding.bottom;
        baseTx = -minX + padding.left;
        baseTy = -minY + padding.top;

        // SVG ì„ íƒ ë° ì´ˆê¸° ì„¤ì •
        svgSelection = d3.select("#tree");

        // ì´ˆê¸° ì¤Œ ì ìš© (width/height ì„¤ì •)
        updateZoom();

        // ğŸŒŸ 3. <g> íƒœê·¸ ìƒì„± (transformì€ updateZoomì—ì„œ ê´€ë¦¬)
        gSelection = svgSelection.append("g");
        updateZoom(); // Apply transform

        // Links (ì„  ê·¸ë¦¬ê¸°)
        gSelection.selectAll(".link")
          .data(root.links())
          .enter()
          .append("path")
          .attr("class", "link")
          .attr("d", d3.linkVertical()
            .x(d => d.x)
            .y(d => d.y));

        // Nodes (ì› ê·¸ë¦¬ê¸°)
        const node = gSelection.selectAll(".node")
          .data(root.descendants())
          .enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", d => `translate(${d.x},${d.y})`);

        node.append("circle")
          .attr("r", 6);

        // Labels (í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°)
        node.append("text")
          .attr("class", "label")
          .attr("y", 20)
          .attr("text-anchor", "middle")
          .text(d => d.data.title);

      } catch (err) {
        console.error(err);
        document.querySelector('.tree-container').innerHTML = '<div style="margin:auto; color:red;">íŠ¸ë¦¬ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</div>';
      }
    }

    loadTree();
  </script>
</body>

</html>